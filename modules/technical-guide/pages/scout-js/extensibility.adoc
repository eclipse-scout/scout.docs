= Extensibility
include::common:partial$_header.adoc[]

The extensibility concepts of Scout allow you to extend or even replace methods of Scout widgets or objects.
You can also use it to extend your own objects or objects from a Scout based third party library.

There are mainly two ways to extend an object:

* Extension by Sub-Classing
* Extension by Composition

== Extension by Sub-Classing

Extending an object using sub-classing is simple and straight forward.
It can either be used to create a custom widget and only use it for certain cases.
And it can even be used to replace a specific widget completely, so your widget will be used every time the original widget is requested.

To extend from a widget, just create a new class, extend from the desired widget class and override the methods you want to adjust.

[source,javascript]
.SpecialStringField.js
----
import {StringField} from '@eclipse-scout/core';

export default class SpecialStringField extends StringField {
  // Override desired methods
}
----

Then, register it in your `index` file as usual and use it in your code by creating a new instance with `scout.create('yournamespace.SpecialStringField')` or as part of a model:

[source,js]
.index.js
----
// ...
export {default as SpecialStringField} from './SpecialStringField';
// ...
window.yournamespace = Object.assign(window.yournamespace || {}, self);
----

[source,javascript]
.ExampleFormModel.js
----
export default () => ({
  rootGroupBox: {
    objectType: 'GroupBox',
    fields: [
      {
        id: 'SpecialField',
        objectType: 'yournamespace.SpecialStringField',
        label: 'Your special field'
      }
    ]
  }
});
----

If you want to replace every `StringField` in your application with `SpecialStringField`, you need to register a new object factory for the `objectType` `StringField` as follows:

[source,javascript]
.Adding a new object factory registration
----
import {SpecialStringField} from './index';
import {scout} from '@eclipse-scout/core';

scout.addObjectFactories({
  'StringField': () => new SpecialStringField()
});
----

More details can be found in the chapter xref:technical-guide:scout-js/object-factory.adoc[].

=== Extending a Model

If you need to extend a widget that uses a model (see xref:technical-guide:scout-js/widget#creating-a-widget-declaratively[Creating a Widget Declaratively]), you may have to extend that model as well.
To do so, extend the widget as described above and either adjust the widgets in the `init` function directly.

[source,javascript]
.ExtendedForm.js
----
import ExampleForm from './ExampleForm';

export default class ExtendedForm extends ExampleForm {
  _init(model) {
    super._init(model);
    this.widget('SpecialField').setLabel('New label for the special field');
  }
}
----

Or, for more complex cases, you can put your model adjustments in a separate file and use the declarative approach.
To do so, override the `_jsonModel` method and use `models.extend` to adapt the original model.

[source,javascript]
.ExtendedForm.js with separate model
----
import {models} from '@eclipse-scout/core';
import ExampleForm from './ExampleForm';
import ExtendedFormModel from './ExtendedFormModel';

export default class ExtendedForm extends ExampleForm {
  _jsonModel() {
    let baseModel = super._jsonModel();
    return models.extend(ExtendedFormModel, baseModel);
  }
}
----

Then, create a new file that will contain your model extensions.

* Use the `target` keyword to specify which widget should be adjusted.
* With the `operation` keyword you define, whether properties should be adjusted (`appendTo`) or new objects should be inserted (`insert`).

The following example contains an extension for the field with the id `SpecialField` that sets a new value for the label.

[source,javascript]
.ExtendedFormModel.js
----
export default () => ({
  type: 'extension',
  extensions: [
    {
      operation: 'appendTo',
      target: {
        id: 'SpecialField'
      },
      extension: {
        label: 'New label for the special field'
      }
    }
  ]
});
----

== Extension by Composition

Extension by Composition allows to have multiple, independent extensions of a Scout object.
It also allows the adjustment of super classes of objects from which it is not possible to inherit, e.g. `FormField` or even `Widget`.

This extension feature works by wrapping functions on the prototype of a Scout object
with a wrapper function which is provided by an extension. The extension feature doesn't rely on
subclassing, instead we simply register one or more extensions for a single Scout class. When a
function is called on an extended object, the functions are called on the registered extensions
first. Since a Scout class can have multiple extensions, we speak of an extension chain, where the
last element of the chain is the original (extended) object.

The base class for all extensions is `Extension`. This class is used to extend an existing
Scout object. In order to use the extension feature you must subclass +Extension+ and
implement an `init` function, where you register the functions you want to extend. Example:

[source,javascript]
----
import {Extension, StringField} from '@eclipse-scout/core';

export default class MyExtension extends Extension {
  init() {
    this.extend(StringField.prototype, '_init');
  }
}
----

Then you implement functions with the same name and signature on the extension class. Example:

[source,javascript]
----
_init(model) {
  // Call the original _init() method of the StringField class
  this.next(model);
  // Extend the instance with a new property called bar with the value foo
  // -> EVERY string field now has this new property
  this.extended.setProperty('bar', 'foo');
}
----

The extension feature sets two properties on the extension instance before the extended method
is called. These two properties are described below. The function scope (this) is set to the extension
instance when the extended function is called.

next:: is a reference to the next extended function or the original function of the extended object,
in case the current extension is the last extension in the extension chain.
extended:: is the extended or original object.

All extensions must be registered in the `_installExtensions` function of your `App` (make sure to use the namespace which is defined in your `index.js` instead of `yournamespace`).

You can find your app in your entrypoint file that is linked in your `webpack.config.js`.
If you already have a custom `App`, just override `_installExtensions` and register the extension.
Otherwise, you need to create a custom `App` first by extending from the Scout `App` (or `RemoteApp` for Scout Classic) and make sure
this new app is initialized rather than the default one.

.CustomApp.js
[source,javascript]
----
import {App, Extension} from '@eclipse-scout/core';

export default class CustomApp extends App {
  _installExtensions() {
    Extension.install([
      'yournamespace.MyExtension'
    ]);
  }
}
----

.Entry point file
[source,javascript]
----
import CustomApp from './CustomApp';

let app = new CustomApp();
app.init();
----
