ifndef::finaldoc[]
include::../_initDoc.adoc[]
endif::finaldoc[]

//fallback for safe mode == secure:
:imgsdir: ../../imgs
:codedir: ../../../code
ifndef::mdledir[:mdledir: .]
:experimental:

[[cha-rest]]
== REST ==

=== REST Resource Conventions ===


[cols="1,1,5", options="header"]
.HTTP Methods for RESTful Services
|===
|HTTP Method
|CRUD
|Description

|POST
|Create
|Is most-often used to create new resources.

POST is not idempotent. Making two identical POST requests will most-likely result in two resources containing the same information or the action executed twice.

|GET
|Read
|Only used to read or retrieve a representation of a resource.

According to the http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9.1.1[HTTP specification] GET (and HEAD) requests are used to read data  and must not change anything! If a REST API wants to violate the specification, such requests must be protected against https://en.wikipedia.org/wiki/Cross-site_request_forgery[CSRF] which is not enabled for GET and HEAD requests by default. See the Scout Bean `org.eclipse.scout.rt.rest.csrf.AntiCsrfHelper` for more details.

GET requests are idempotent, which means that making multiple identical requests ends up having the same result as a single request (assuming the data has not been changed in the meantime).

|PUT
|Update/Replace
|Is most-often used to update resources.

PUT expects to send the complete resource (not like PATCH) and is idempotent. In other words, if you create or update a resource using PUT and then make that same call again, the resource is still there and still has the same state as it did with the first call.

If, for instance, calling PUT on a resource increments a counter within the resource, the call is no longer idempotent. In such a scenario it is strongly recommended to use POST for non-idempotent requests.

|PATCH
|Update
|PATCH is used to update resources. The PATCH request typically only contains the changes to the resource, not the complete resource.

PATCH is not required to be idempotent. But it is possible to implement it in a way to be idempotent, which also helps prevent bad outcomes from collisions between multiple requests on the same resource.

|DELETE
|Delete
|Used to delete a resource.

DELETE operations are idempotent concerning the result but may return another status code after the first deletion (e.g. 404 NOT FOUND).

|===


=== REST Resource Provider ===
A REST resource using the http://www.oracle.com/technetwork/java/javaee/tech/jax-rs-159890.html[JAX-RS] API is implemented by a POJO class annotated with a set of annotations.

The Scout module `org.eclipse.scout.rt.rest` contains the basic `IRestResource` marker interface which integrates REST resources within the Scout framework.
The interface is annotated by `@Bean` allowing the Scout platform to load and register all REST resources automatically at startup using the Jandex class inventory.

[source,java]
.Example: REST resource
----
include::{codedir}/org.eclipse.scout.docs.snippets/src/main/java/org/eclipse/scout/docs/snippets/rest/ExampleResource.java[tags=class]
----

==== REST Resource Registration ====

All available REST resources are automatically registered by the `RestApplication` class while the Scout platform startup.

Add the following snippet to your `web.xml` file to expose your REST API using the `/api` context path:

[source,xml]
.web.xml
----
<!-- JAX-RS Jersey Servlet -->
<servlet>
  <servlet-name>api</servlet-name>
  <servlet-class>org.glassfish.jersey.servlet.ServletContainer</servlet-class>
  <init-param>
    <param-name>javax.ws.rs.Application</param-name>
    <param-value>org.eclipse.scout.rt.rest.RestApplication</param-value>
  </init-param>
  <load-on-startup>1</load-on-startup>
</servlet>

<servlet-mapping>
  <servlet-name>api</servlet-name>
  <url-pattern>/api/*</url-pattern>
</servlet-mapping>
----

==== Extend REST Application
The JAX-RS application API (`javax.ws.rs.core.Application`) allows a REST application implementation to specify a set of classes, a set of singleton instances and a map of custom properties to be registered.
The Scout implementation of the REST application class `org.eclipse.scout.rt.rest.RestApplication` allows to contribute classes, singletons and properties without needing to extend the `RestApplication` class.

Three different contributor interfaces are available for contributions:

* `IRestApplicationClassesContributor` to contribute any classes
* `IRestApplicationSingletonsContributor` to contribute any object instances (singletons)
* `IRestApplicationPropertiesContributor` to contribute key/value properties

[source,java]
.Example class contributor
----
public static class ExampleClassContributor implements IRestApplicationClassesContributor {
  @Override
  public Set<Class<?>> contribute() {
    return Collections.singleton(MyCustomExample.class);
  }
}
----

==== Data Objects ====
Scout data objects may be used as request and response objects for REST APIs.
See <<cha-data-objects>> for details and examples.

==== Marshaller ====

A REST API may be used by non-Java consumers. In order to communicate using a platform-independent format, usually REST services use JSON as transport format.
The marshaller between Java data objects and JSON is abstracted in the JAX-RS specification.
Using the `@Produces(MediaType.APPLICATION_JSON)` annotation, each REST service method specifies the produces data format.

The Scout REST integration uses the popular Jackson library as default marshaller.
Add a Maven dependency to `jersey-media-json-jackson` in your application `pom.xml` to use Jackson as JAX-RS marshaller with the Jersey JAX-RS implementation.

Additionally add a dependency to the Scout module `org.eclipse.scout.rt.rest.jackson`.
This module adds a set of Jackson additions in order to use Jackson with Scout data objects.

==== RunContext ====
Like a usual service call using the Scout service tunnel a REST request must ensure that processing of the request takes place within a `RunContext`.
The `HttpServerRunContextFilter` or `HttpRunContextFilter` can be used to intercept incoming REST requests and wrap them within a Scout RunContext.
`HttpServerRunContextFilter` can be used if a Scout server dependency is available. Optionally this filter also supports the creation of a Scout server session if this should be required (stateful). Refer to the javadoc for more details.
The `HttpRunContextFilter` on the other hand does not provide session support and is always stateless.

Therefore a REST resource implementation is not required to deal with setting up a RunContext to wrap the request within each method.
The filter must be added in the `web.xml` configuration file and should be configured to be called after the authentication filter.
The filter expects that the authentication has been performed and that a `subject` is available (JAAS context).
All following filters and servlets and thus also the REST resources run automatically in the correct context.

[source,xml]
.web.xml registration example for HttpServerRunContextFilter.
----
<filter>
   <filter-name>HttpServerRunContextFilter</filter-name>
   <filter-class>org.eclipse.scout.rt.server.context.HttpServerRunContextFilter</filter-class>
   <init-param>
     <param-name>session</param-name>
     <param-value>false</param-value>
   </init-param>
 </filter>

<filter-mapping>
  <filter-name>HttpServerRunContextFilter</filter-name>
  <url-pattern>/api/*</url-pattern>
</filter-mapping>
----

Beside the `subject` and other attributes the `HttpServerRunContextFilter` and `HttpRunContextFilter` setup the Correlation ID, as well as the locale.
Both values are read from the incoming request header, the caller must ensure that the headers `Accept-Language` and `X-Scout-Correlation-Id` are set accordingly.

=== REST Client ===

The Scout module `org.eclipse.scout.rt.rest` offers a set of helper classes in order to call REST services.

Each REST service endpoint is represented by a specific REST resource client helper class. The (usually application scoped bean) class is used to specify the
resource URL and additional properties used to build up the connection (authentication, additional headers,...). Further it provides a call-back method for transforming
unsuccessful responses into appropriate exception.

At least the REST resource's base URI must be specified:

[source,java]
.Example: REST resource client helper
----
include::{codedir}/org.eclipse.scout.docs.snippets/src/main/java/org/eclipse/scout/docs/snippets/rest/ExampleRestClientHelper.java[tags=class]
----
<1> Declare base uri.
<2> Custom exception transformer that is used as default strategy for all invocations prepared by this helper. (This is just for demonstration. Better extend
    `org.eclipse.scout.rt.rest.client.proxy.AbstractEntityRestClientExceptionTransformer`).

Based on the helper class, an example REST resource client may be implemented:

[source,java]
.Example: REST resource client
----
include::{codedir}/org.eclipse.scout.docs.snippets/src/main/java/org/eclipse/scout/docs/snippets/rest/ExampleResourceClient.java[tags=class]
----
<1> HTTP GET example: Directly read response into an object. Exceptions are transformed transparently and the underlying resources are released (e.g. HTTP client).
<2> HTTP POST example: Again, directly read the response into an object.
<3> HTTP DELETE example: This delete operation does not send a response if it was successful. Hence close the returned `Response` explicitly to release underlying resources
    (see next line). Note: Unsuccessful responses are already handled by the REST client proxy.
<4> Use custom exception transformer.
